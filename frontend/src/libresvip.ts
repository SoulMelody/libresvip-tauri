// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               v6.33.0
// source: libresvip.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientReadableStream,
  type ClientUnaryCall,
  type handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "LibreSVIP";

export enum PluginCategory {
  INPUT = 0,
  OUTPUT = 1,
  MIDDLEWARE = 2,
  UNRECOGNIZED = -1,
}

export function pluginCategoryFromJSON(object: any): PluginCategory {
  switch (object) {
    case 0:
    case "INPUT":
      return PluginCategory.INPUT;
    case 1:
    case "OUTPUT":
      return PluginCategory.OUTPUT;
    case 2:
    case "MIDDLEWARE":
      return PluginCategory.MIDDLEWARE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PluginCategory.UNRECOGNIZED;
  }
}

export function pluginCategoryToJSON(object: PluginCategory): string {
  switch (object) {
    case PluginCategory.INPUT:
      return "INPUT";
    case PluginCategory.OUTPUT:
      return "OUTPUT";
    case PluginCategory.MIDDLEWARE:
      return "MIDDLEWARE";
    case PluginCategory.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ConversionMode {
  DIRECT = 0,
  SPLIT = 1,
  MERGE = 2,
  UNRECOGNIZED = -1,
}

export function conversionModeFromJSON(object: any): ConversionMode {
  switch (object) {
    case 0:
    case "DIRECT":
      return ConversionMode.DIRECT;
    case 1:
    case "SPLIT":
      return ConversionMode.SPLIT;
    case 2:
    case "MERGE":
      return ConversionMode.MERGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConversionMode.UNRECOGNIZED;
  }
}

export function conversionModeToJSON(object: ConversionMode): string {
  switch (object) {
    case ConversionMode.DIRECT:
      return "DIRECT";
    case ConversionMode.SPLIT:
      return "SPLIT";
    case ConversionMode.MERGE:
      return "MERGE";
    case ConversionMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ConflictPolicy {
  SKIP = 0,
  PROMPT = 1,
  UNRECOGNIZED = -1,
}

export function conflictPolicyFromJSON(object: any): ConflictPolicy {
  switch (object) {
    case 0:
    case "SKIP":
      return ConflictPolicy.SKIP;
    case 1:
    case "PROMPT":
      return ConflictPolicy.PROMPT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConflictPolicy.UNRECOGNIZED;
  }
}

export function conflictPolicyToJSON(object: ConflictPolicy): string {
  switch (object) {
    case ConflictPolicy.SKIP:
      return "SKIP";
    case ConflictPolicy.PROMPT:
      return "PROMPT";
    case ConflictPolicy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface PluginInfo {
  identifier: string;
  name: string;
  version: string;
  description: string;
  author: string;
  website: string;
  jsonSchema: string;
  /** additional fields for io plugins */
  fileFormat: string;
  suffixes: string[];
  iconBase64: string;
  uiJsonSchema: string;
}

export interface PluginInfosRequest {
  category: PluginCategory;
  language: string;
}

export interface PluginInfosResponse {
  values: PluginInfo[];
}

export interface ConversionGroup {
  groupId: string;
  fileContents: Uint8Array[];
}

export interface ConversionRequest {
  inputFormat: string;
  outputFormat: string;
  mode: ConversionMode;
  maxTrackCount: number;
  groups: ConversionGroup[];
  inputOptions: string;
  outputOptions: string;
  middlewareOptions: { [key: string]: string };
}

export interface ConversionRequest_MiddlewareOptionsEntry {
  key: string;
  value: string;
}

export interface SingleConversionResult {
  groupId: string;
  completed: boolean;
  errorMessage: string;
  warningMessages: string[];
}

export interface VersionInfo {
  version: string;
}

export interface MoveFileRequest {
  groupId: string;
  forceOverwrite: boolean;
}

export interface MoveFileResponse {
  groupId: string;
  outputPath: string;
  conflictPolicy: ConflictPolicy;
}

function createBasePluginInfo(): PluginInfo {
  return {
    identifier: "",
    name: "",
    version: "",
    description: "",
    author: "",
    website: "",
    jsonSchema: "",
    fileFormat: "",
    suffixes: [],
    iconBase64: "",
    uiJsonSchema: "",
  };
}

export const PluginInfo: MessageFns<PluginInfo> = {
  encode(message: PluginInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.identifier !== "") {
      writer.uint32(10).string(message.identifier);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.version !== "") {
      writer.uint32(26).string(message.version);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.author !== "") {
      writer.uint32(42).string(message.author);
    }
    if (message.website !== "") {
      writer.uint32(50).string(message.website);
    }
    if (message.jsonSchema !== "") {
      writer.uint32(58).string(message.jsonSchema);
    }
    if (message.fileFormat !== "") {
      writer.uint32(66).string(message.fileFormat);
    }
    for (const v of message.suffixes) {
      writer.uint32(74).string(v!);
    }
    if (message.iconBase64 !== "") {
      writer.uint32(82).string(message.iconBase64);
    }
    if (message.uiJsonSchema !== "") {
      writer.uint32(90).string(message.uiJsonSchema);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PluginInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePluginInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.identifier = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.author = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.website = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.jsonSchema = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.fileFormat = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.suffixes.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.iconBase64 = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.uiJsonSchema = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PluginInfo {
    return {
      identifier: isSet(object.identifier) ? globalThis.String(object.identifier) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      author: isSet(object.author) ? globalThis.String(object.author) : "",
      website: isSet(object.website) ? globalThis.String(object.website) : "",
      jsonSchema: isSet(object.jsonSchema)
        ? globalThis.String(object.jsonSchema)
        : isSet(object.json_schema)
        ? globalThis.String(object.json_schema)
        : "",
      fileFormat: isSet(object.fileFormat)
        ? globalThis.String(object.fileFormat)
        : isSet(object.file_format)
        ? globalThis.String(object.file_format)
        : "",
      suffixes: globalThis.Array.isArray(object?.suffixes) ? object.suffixes.map((e: any) => globalThis.String(e)) : [],
      iconBase64: isSet(object.iconBase64)
        ? globalThis.String(object.iconBase64)
        : isSet(object.icon_base64)
        ? globalThis.String(object.icon_base64)
        : "",
      uiJsonSchema: isSet(object.uiJsonSchema)
        ? globalThis.String(object.uiJsonSchema)
        : isSet(object.ui_json_schema)
        ? globalThis.String(object.ui_json_schema)
        : "",
    };
  },

  toJSON(message: PluginInfo): unknown {
    const obj: any = {};
    if (message.identifier !== "") {
      obj.identifier = message.identifier;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.author !== "") {
      obj.author = message.author;
    }
    if (message.website !== "") {
      obj.website = message.website;
    }
    if (message.jsonSchema !== "") {
      obj.jsonSchema = message.jsonSchema;
    }
    if (message.fileFormat !== "") {
      obj.fileFormat = message.fileFormat;
    }
    if (message.suffixes?.length) {
      obj.suffixes = message.suffixes;
    }
    if (message.iconBase64 !== "") {
      obj.iconBase64 = message.iconBase64;
    }
    if (message.uiJsonSchema !== "") {
      obj.uiJsonSchema = message.uiJsonSchema;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PluginInfo>, I>>(base?: I): PluginInfo {
    return PluginInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PluginInfo>, I>>(object: I): PluginInfo {
    const message = createBasePluginInfo();
    message.identifier = object.identifier ?? "";
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    message.description = object.description ?? "";
    message.author = object.author ?? "";
    message.website = object.website ?? "";
    message.jsonSchema = object.jsonSchema ?? "";
    message.fileFormat = object.fileFormat ?? "";
    message.suffixes = object.suffixes?.map((e) => e) || [];
    message.iconBase64 = object.iconBase64 ?? "";
    message.uiJsonSchema = object.uiJsonSchema ?? "";
    return message;
  },
};

function createBasePluginInfosRequest(): PluginInfosRequest {
  return { category: 0, language: "" };
}

export const PluginInfosRequest: MessageFns<PluginInfosRequest> = {
  encode(message: PluginInfosRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.category !== 0) {
      writer.uint32(8).int32(message.category);
    }
    if (message.language !== "") {
      writer.uint32(18).string(message.language);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PluginInfosRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePluginInfosRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.language = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PluginInfosRequest {
    return {
      category: isSet(object.category) ? pluginCategoryFromJSON(object.category) : 0,
      language: isSet(object.language) ? globalThis.String(object.language) : "",
    };
  },

  toJSON(message: PluginInfosRequest): unknown {
    const obj: any = {};
    if (message.category !== 0) {
      obj.category = pluginCategoryToJSON(message.category);
    }
    if (message.language !== "") {
      obj.language = message.language;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PluginInfosRequest>, I>>(base?: I): PluginInfosRequest {
    return PluginInfosRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PluginInfosRequest>, I>>(object: I): PluginInfosRequest {
    const message = createBasePluginInfosRequest();
    message.category = object.category ?? 0;
    message.language = object.language ?? "";
    return message;
  },
};

function createBasePluginInfosResponse(): PluginInfosResponse {
  return { values: [] };
}

export const PluginInfosResponse: MessageFns<PluginInfosResponse> = {
  encode(message: PluginInfosResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.values) {
      PluginInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PluginInfosResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePluginInfosResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.values.push(PluginInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PluginInfosResponse {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => PluginInfo.fromJSON(e)) : [],
    };
  },

  toJSON(message: PluginInfosResponse): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values.map((e) => PluginInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PluginInfosResponse>, I>>(base?: I): PluginInfosResponse {
    return PluginInfosResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PluginInfosResponse>, I>>(object: I): PluginInfosResponse {
    const message = createBasePluginInfosResponse();
    message.values = object.values?.map((e) => PluginInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseConversionGroup(): ConversionGroup {
  return { groupId: "", fileContents: [] };
}

export const ConversionGroup: MessageFns<ConversionGroup> = {
  encode(message: ConversionGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupId !== "") {
      writer.uint32(10).string(message.groupId);
    }
    for (const v of message.fileContents) {
      writer.uint32(18).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConversionGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversionGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fileContents.push(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversionGroup {
    return {
      groupId: isSet(object.groupId)
        ? globalThis.String(object.groupId)
        : isSet(object.group_id)
        ? globalThis.String(object.group_id)
        : "",
      fileContents: globalThis.Array.isArray(object?.fileContents)
        ? object.fileContents.map((e: any) => bytesFromBase64(e))
        : globalThis.Array.isArray(object?.file_contents)
        ? object.file_contents.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: ConversionGroup): unknown {
    const obj: any = {};
    if (message.groupId !== "") {
      obj.groupId = message.groupId;
    }
    if (message.fileContents?.length) {
      obj.fileContents = message.fileContents.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConversionGroup>, I>>(base?: I): ConversionGroup {
    return ConversionGroup.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConversionGroup>, I>>(object: I): ConversionGroup {
    const message = createBaseConversionGroup();
    message.groupId = object.groupId ?? "";
    message.fileContents = object.fileContents?.map((e) => e) || [];
    return message;
  },
};

function createBaseConversionRequest(): ConversionRequest {
  return {
    inputFormat: "",
    outputFormat: "",
    mode: 0,
    maxTrackCount: 0,
    groups: [],
    inputOptions: "",
    outputOptions: "",
    middlewareOptions: {},
  };
}

export const ConversionRequest: MessageFns<ConversionRequest> = {
  encode(message: ConversionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inputFormat !== "") {
      writer.uint32(10).string(message.inputFormat);
    }
    if (message.outputFormat !== "") {
      writer.uint32(18).string(message.outputFormat);
    }
    if (message.mode !== 0) {
      writer.uint32(24).int32(message.mode);
    }
    if (message.maxTrackCount !== 0) {
      writer.uint32(32).int32(message.maxTrackCount);
    }
    for (const v of message.groups) {
      ConversionGroup.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.inputOptions !== "") {
      writer.uint32(50).string(message.inputOptions);
    }
    if (message.outputOptions !== "") {
      writer.uint32(58).string(message.outputOptions);
    }
    globalThis.Object.entries(message.middlewareOptions).forEach(([key, value]: [string, string]) => {
      ConversionRequest_MiddlewareOptionsEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConversionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.inputFormat = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.outputFormat = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.maxTrackCount = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.groups.push(ConversionGroup.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.inputOptions = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.outputOptions = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const entry8 = ConversionRequest_MiddlewareOptionsEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.middlewareOptions[entry8.key] = entry8.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversionRequest {
    return {
      inputFormat: isSet(object.inputFormat)
        ? globalThis.String(object.inputFormat)
        : isSet(object.input_format)
        ? globalThis.String(object.input_format)
        : "",
      outputFormat: isSet(object.outputFormat)
        ? globalThis.String(object.outputFormat)
        : isSet(object.output_format)
        ? globalThis.String(object.output_format)
        : "",
      mode: isSet(object.mode) ? conversionModeFromJSON(object.mode) : 0,
      maxTrackCount: isSet(object.maxTrackCount)
        ? globalThis.Number(object.maxTrackCount)
        : isSet(object.max_track_count)
        ? globalThis.Number(object.max_track_count)
        : 0,
      groups: globalThis.Array.isArray(object?.groups)
        ? object.groups.map((e: any) => ConversionGroup.fromJSON(e))
        : [],
      inputOptions: isSet(object.inputOptions)
        ? globalThis.String(object.inputOptions)
        : isSet(object.input_options)
        ? globalThis.String(object.input_options)
        : "",
      outputOptions: isSet(object.outputOptions)
        ? globalThis.String(object.outputOptions)
        : isSet(object.output_options)
        ? globalThis.String(object.output_options)
        : "",
      middlewareOptions: isObject(object.middlewareOptions)
        ? (globalThis.Object.entries(object.middlewareOptions) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : isObject(object.middleware_options)
        ? (globalThis.Object.entries(object.middleware_options) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: ConversionRequest): unknown {
    const obj: any = {};
    if (message.inputFormat !== "") {
      obj.inputFormat = message.inputFormat;
    }
    if (message.outputFormat !== "") {
      obj.outputFormat = message.outputFormat;
    }
    if (message.mode !== 0) {
      obj.mode = conversionModeToJSON(message.mode);
    }
    if (message.maxTrackCount !== 0) {
      obj.maxTrackCount = Math.round(message.maxTrackCount);
    }
    if (message.groups?.length) {
      obj.groups = message.groups.map((e) => ConversionGroup.toJSON(e));
    }
    if (message.inputOptions !== "") {
      obj.inputOptions = message.inputOptions;
    }
    if (message.outputOptions !== "") {
      obj.outputOptions = message.outputOptions;
    }
    if (message.middlewareOptions) {
      const entries = globalThis.Object.entries(message.middlewareOptions) as [string, string][];
      if (entries.length > 0) {
        obj.middlewareOptions = {};
        entries.forEach(([k, v]) => {
          obj.middlewareOptions[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConversionRequest>, I>>(base?: I): ConversionRequest {
    return ConversionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConversionRequest>, I>>(object: I): ConversionRequest {
    const message = createBaseConversionRequest();
    message.inputFormat = object.inputFormat ?? "";
    message.outputFormat = object.outputFormat ?? "";
    message.mode = object.mode ?? 0;
    message.maxTrackCount = object.maxTrackCount ?? 0;
    message.groups = object.groups?.map((e) => ConversionGroup.fromPartial(e)) || [];
    message.inputOptions = object.inputOptions ?? "";
    message.outputOptions = object.outputOptions ?? "";
    message.middlewareOptions = (globalThis.Object.entries(object.middlewareOptions ?? {}) as [string, string][])
      .reduce((acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      }, {});
    return message;
  },
};

function createBaseConversionRequest_MiddlewareOptionsEntry(): ConversionRequest_MiddlewareOptionsEntry {
  return { key: "", value: "" };
}

export const ConversionRequest_MiddlewareOptionsEntry: MessageFns<ConversionRequest_MiddlewareOptionsEntry> = {
  encode(message: ConversionRequest_MiddlewareOptionsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConversionRequest_MiddlewareOptionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversionRequest_MiddlewareOptionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversionRequest_MiddlewareOptionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ConversionRequest_MiddlewareOptionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConversionRequest_MiddlewareOptionsEntry>, I>>(
    base?: I,
  ): ConversionRequest_MiddlewareOptionsEntry {
    return ConversionRequest_MiddlewareOptionsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConversionRequest_MiddlewareOptionsEntry>, I>>(
    object: I,
  ): ConversionRequest_MiddlewareOptionsEntry {
    const message = createBaseConversionRequest_MiddlewareOptionsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSingleConversionResult(): SingleConversionResult {
  return { groupId: "", completed: false, errorMessage: "", warningMessages: [] };
}

export const SingleConversionResult: MessageFns<SingleConversionResult> = {
  encode(message: SingleConversionResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupId !== "") {
      writer.uint32(10).string(message.groupId);
    }
    if (message.completed !== false) {
      writer.uint32(16).bool(message.completed);
    }
    if (message.errorMessage !== "") {
      writer.uint32(26).string(message.errorMessage);
    }
    for (const v of message.warningMessages) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleConversionResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleConversionResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.completed = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.warningMessages.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleConversionResult {
    return {
      groupId: isSet(object.groupId)
        ? globalThis.String(object.groupId)
        : isSet(object.group_id)
        ? globalThis.String(object.group_id)
        : "",
      completed: isSet(object.completed) ? globalThis.Boolean(object.completed) : false,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : isSet(object.error_message)
        ? globalThis.String(object.error_message)
        : "",
      warningMessages: globalThis.Array.isArray(object?.warningMessages)
        ? object.warningMessages.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.warning_messages)
        ? object.warning_messages.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: SingleConversionResult): unknown {
    const obj: any = {};
    if (message.groupId !== "") {
      obj.groupId = message.groupId;
    }
    if (message.completed !== false) {
      obj.completed = message.completed;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.warningMessages?.length) {
      obj.warningMessages = message.warningMessages;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleConversionResult>, I>>(base?: I): SingleConversionResult {
    return SingleConversionResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleConversionResult>, I>>(object: I): SingleConversionResult {
    const message = createBaseSingleConversionResult();
    message.groupId = object.groupId ?? "";
    message.completed = object.completed ?? false;
    message.errorMessage = object.errorMessage ?? "";
    message.warningMessages = object.warningMessages?.map((e) => e) || [];
    return message;
  },
};

function createBaseVersionInfo(): VersionInfo {
  return { version: "" };
}

export const VersionInfo: MessageFns<VersionInfo> = {
  encode(message: VersionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VersionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVersionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VersionInfo {
    return { version: isSet(object.version) ? globalThis.String(object.version) : "" };
  },

  toJSON(message: VersionInfo): unknown {
    const obj: any = {};
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VersionInfo>, I>>(base?: I): VersionInfo {
    return VersionInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VersionInfo>, I>>(object: I): VersionInfo {
    const message = createBaseVersionInfo();
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseMoveFileRequest(): MoveFileRequest {
  return { groupId: "", forceOverwrite: false };
}

export const MoveFileRequest: MessageFns<MoveFileRequest> = {
  encode(message: MoveFileRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupId !== "") {
      writer.uint32(10).string(message.groupId);
    }
    if (message.forceOverwrite !== false) {
      writer.uint32(16).bool(message.forceOverwrite);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MoveFileRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMoveFileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.forceOverwrite = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MoveFileRequest {
    return {
      groupId: isSet(object.groupId)
        ? globalThis.String(object.groupId)
        : isSet(object.group_id)
        ? globalThis.String(object.group_id)
        : "",
      forceOverwrite: isSet(object.forceOverwrite)
        ? globalThis.Boolean(object.forceOverwrite)
        : isSet(object.force_overwrite)
        ? globalThis.Boolean(object.force_overwrite)
        : false,
    };
  },

  toJSON(message: MoveFileRequest): unknown {
    const obj: any = {};
    if (message.groupId !== "") {
      obj.groupId = message.groupId;
    }
    if (message.forceOverwrite !== false) {
      obj.forceOverwrite = message.forceOverwrite;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MoveFileRequest>, I>>(base?: I): MoveFileRequest {
    return MoveFileRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MoveFileRequest>, I>>(object: I): MoveFileRequest {
    const message = createBaseMoveFileRequest();
    message.groupId = object.groupId ?? "";
    message.forceOverwrite = object.forceOverwrite ?? false;
    return message;
  },
};

function createBaseMoveFileResponse(): MoveFileResponse {
  return { groupId: "", outputPath: "", conflictPolicy: 0 };
}

export const MoveFileResponse: MessageFns<MoveFileResponse> = {
  encode(message: MoveFileResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupId !== "") {
      writer.uint32(10).string(message.groupId);
    }
    if (message.outputPath !== "") {
      writer.uint32(18).string(message.outputPath);
    }
    if (message.conflictPolicy !== 0) {
      writer.uint32(24).int32(message.conflictPolicy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MoveFileResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMoveFileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.outputPath = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.conflictPolicy = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MoveFileResponse {
    return {
      groupId: isSet(object.groupId)
        ? globalThis.String(object.groupId)
        : isSet(object.group_id)
        ? globalThis.String(object.group_id)
        : "",
      outputPath: isSet(object.outputPath)
        ? globalThis.String(object.outputPath)
        : isSet(object.output_path)
        ? globalThis.String(object.output_path)
        : "",
      conflictPolicy: isSet(object.conflictPolicy)
        ? conflictPolicyFromJSON(object.conflictPolicy)
        : isSet(object.conflict_policy)
        ? conflictPolicyFromJSON(object.conflict_policy)
        : 0,
    };
  },

  toJSON(message: MoveFileResponse): unknown {
    const obj: any = {};
    if (message.groupId !== "") {
      obj.groupId = message.groupId;
    }
    if (message.outputPath !== "") {
      obj.outputPath = message.outputPath;
    }
    if (message.conflictPolicy !== 0) {
      obj.conflictPolicy = conflictPolicyToJSON(message.conflictPolicy);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MoveFileResponse>, I>>(base?: I): MoveFileResponse {
    return MoveFileResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MoveFileResponse>, I>>(object: I): MoveFileResponse {
    const message = createBaseMoveFileResponse();
    message.groupId = object.groupId ?? "";
    message.outputPath = object.outputPath ?? "";
    message.conflictPolicy = object.conflictPolicy ?? 0;
    return message;
  },
};

export type ConversionService = typeof ConversionService;
export const ConversionService = {
  pluginInfos: {
    path: "/LibreSVIP.Conversion/PluginInfos",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PluginInfosRequest): Buffer => Buffer.from(PluginInfosRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PluginInfosRequest => PluginInfosRequest.decode(value),
    responseSerialize: (value: PluginInfosResponse): Buffer => Buffer.from(PluginInfosResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PluginInfosResponse => PluginInfosResponse.decode(value),
  },
  convert: {
    path: "/LibreSVIP.Conversion/Convert",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: ConversionRequest): Buffer => Buffer.from(ConversionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ConversionRequest => ConversionRequest.decode(value),
    responseSerialize: (value: SingleConversionResult): Buffer =>
      Buffer.from(SingleConversionResult.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleConversionResult => SingleConversionResult.decode(value),
  },
  version: {
    path: "/LibreSVIP.Conversion/Version",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: VersionInfo): Buffer => Buffer.from(VersionInfo.encode(value).finish()),
    requestDeserialize: (value: Buffer): VersionInfo => VersionInfo.decode(value),
    responseSerialize: (value: VersionInfo): Buffer => Buffer.from(VersionInfo.encode(value).finish()),
    responseDeserialize: (value: Buffer): VersionInfo => VersionInfo.decode(value),
  },
  moveFile: {
    path: "/LibreSVIP.Conversion/MoveFile",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: MoveFileRequest): Buffer => Buffer.from(MoveFileRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): MoveFileRequest => MoveFileRequest.decode(value),
    responseSerialize: (value: MoveFileResponse): Buffer => Buffer.from(MoveFileResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MoveFileResponse => MoveFileResponse.decode(value),
  },
} as const;

export interface ConversionServer extends UntypedServiceImplementation {
  pluginInfos: handleUnaryCall<PluginInfosRequest, PluginInfosResponse>;
  convert: handleServerStreamingCall<ConversionRequest, SingleConversionResult>;
  version: handleUnaryCall<VersionInfo, VersionInfo>;
  moveFile: handleServerStreamingCall<MoveFileRequest, MoveFileResponse>;
}

export interface ConversionClient extends Client {
  pluginInfos(
    request: PluginInfosRequest,
    callback: (error: ServiceError | null, response: PluginInfosResponse) => void,
  ): ClientUnaryCall;
  pluginInfos(
    request: PluginInfosRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PluginInfosResponse) => void,
  ): ClientUnaryCall;
  pluginInfos(
    request: PluginInfosRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PluginInfosResponse) => void,
  ): ClientUnaryCall;
  convert(request: ConversionRequest, options?: Partial<CallOptions>): ClientReadableStream<SingleConversionResult>;
  convert(
    request: ConversionRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<SingleConversionResult>;
  version(request: VersionInfo, callback: (error: ServiceError | null, response: VersionInfo) => void): ClientUnaryCall;
  version(
    request: VersionInfo,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: VersionInfo) => void,
  ): ClientUnaryCall;
  version(
    request: VersionInfo,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: VersionInfo) => void,
  ): ClientUnaryCall;
  moveFile(request: MoveFileRequest, options?: Partial<CallOptions>): ClientReadableStream<MoveFileResponse>;
  moveFile(
    request: MoveFileRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<MoveFileResponse>;
}

export const ConversionClient = makeGenericClientConstructor(ConversionService, "LibreSVIP.Conversion") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): ConversionClient;
  service: typeof ConversionService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
